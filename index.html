<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="SEM-bootloader : SEM TFTP bootloader for Arduino Ethernet (incl. support for Atmega 1284P and Wiznet W5200, W5500)" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>SEM-bootloader</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/arjenhiemstra/SEM-Bootloader">View on GitHub</a>

          <h1 id="project_title">SEM-bootloader</h1>
          <h2 id="project_tagline">SEM TFTP bootloader for Arduino Ethernet (incl. support for Atmega 1284P and Wiznet W5200, W5500)</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/arjenhiemstra/SEM-Bootloader/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/arjenhiemstra/SEM-Bootloader/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="sem-bootloader-for-arduino" class="anchor" href="#sem-bootloader-for-arduino"><span class="octicon octicon-link"></span></a><a href="http://github.com/arjenhiemstra/SEM-Bootloader/">SEM Bootloader for Arduino</a>
</h1>

<h3>
<a name="tftp-bootloader-for-atmega328patmega2560atmega1284p" class="anchor" href="#tftp-bootloader-for-atmega328patmega2560atmega1284p"><span class="octicon octicon-link"></span></a>TFTP Bootloader for ATmega328P/Atmega2560/Atmega1284P</h3>

<h4>
<a name="w-support-for-wiznet5100-w5200-and-w5500" class="anchor" href="#w-support-for-wiznet5100-w5200-and-w5500"><span class="octicon octicon-link"></span></a>/w support for Wiznet5100, W5200 and W5500</h4>

<p>This is a beta stage bootloader for Arduino Ethernet board and the regular Arduino with Ethernet Shield.
It is based on previous unfinished work by the Arduino developers. The bootloader implements a TFTP
server on the Arduino board and flashing works using any regular TFTP client.</p>

<h2>
<a name="the-files-and-folders-in-this-repository" class="anchor" href="#the-files-and-folders-in-this-repository"><span class="octicon octicon-link"></span></a>The Files and Folders in this Repository</h2>

<p>The structure of this repository is made to follow the standarts of the Arduino IDE. This way you can
simply copy the folders in your sketchbook and be ready</p>

<ul>
<li>hardware: This is where the bootloader resides.</li>
<li>java-client: Demo client for the bootloader. Inherited by the initial project. Untested and probably non-functional</li>
<li>libraries: Helper libraries to support functions of the bootloader</li>
<li>utilities: Various stuff used for development and debugging</li>
</ul><h2>
<a name="downloading-and-installing-files" class="anchor" href="#downloading-and-installing-files"><span class="octicon octicon-link"></span></a>Downloading and Installing Files</h2>

<p>First of all, you need to clone or download the repository. To clone the repository you need to have
git installed, then you can run <code>git clone https://github.com/arjenhiemstra/SEM-Bootloader.git</code> in a
directory. This way you can later update your local repository by running <code>git pull</code> inside the
<strong>SEM-Bootloader</strong> directory.</p>

<p>In case you want to avoid this hassle, you can use the <strong>ZIP</strong> button at the top of the page to download
the latest snapshot of the repository in a zip archive and extract it.</p>

<p>After that you have to copy the <strong>hardware</strong> and <strong>libraries</strong> folders inside your sketchbook folder.
Take extra care during coping not to overwrite any other files. Restart the Arduino IDE to load the new
boards and libraries.</p>

<h2>
<a name="installing-the-bootloader" class="anchor" href="#installing-the-bootloader"><span class="octicon octicon-link"></span></a>Installing the Bootloader</h2>

<p>To burn the bootloader, you will need an ISP(in-system programmer) like <a href="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=2726">AVR-ISP</a>, <a href="http://www.ladyada.net/make/usbtinyisp/">USBtinyISP</a>
or you can build a <a href="http://arduino.cc/en/Hacking/ParallelProgrammer">ParallelProgrammer</a> or an <a href="http://arduino.cc/en/Tutorial/ArduinoISP">ArduinoISP</a>. The first three programmers should
be connected to the ICSP pins (the 2 by 3 pin header) and make sure you plug it in the right way. The
board must be powered by an external power supply or the USB port. In the case of <em>ArduinoISP</em> you
should consult the above link for further instructions on how to build and use.</p>

<p>After you have connected the Arduino board and the programmer to your computer launch the Arduino IDE.
Navigate to the <strong>Tools</strong> &gt; <strong>Board</strong> menu and select <code>SEMboot Atmega &lt;chip&gt; (&lt;Wiznet Chip&gt;)</code> which
reflects your Arduino/Atmega board and wiznet chip combination.
Then go to <strong>Tools</strong> &gt; <strong>Programmer</strong> and select the programmer you are using.
In case you are using <em>ArduinoISP</em>, make sure that the selected port in the <strong>Tools</strong> &gt; <strong>Serial Port</strong>
menu refers to the <em>ArduinoISP</em> and not the board that you want to burn the bootloader on. Now, just
launch the <strong>Tools</strong> &gt; <strong>Burn Bootloader</strong> command and wait for about 15 seconds for the operation
to complete.</p>

<p>In the case of <em>Arduino Mega</em> the previous ISPs do not reliably work because of design differences. To
install the bootloader in these boards you will need one of the more expensive models,
like <a href="http://www.atmel.com/tools/AVRISPMKII.aspx">Atmel's AVRISP mkII</a>, <a href="https://www.olimex.com/Products/AVR/Programmers/AVR-ISP-MK2/">Olimex's AVR-ISP-MK2</a> or another similar programmer. If you don't
have any compatible programmer but more than one Arduinos available, you can use Nick Gammon's
excellent <a href="http://www.gammon.com.au/forum/?id=11635">guide</a> on how to use one to program the other. This method has been reported to work
for flashing <strong>Ariadne</strong> on <em>Arduino Mega</em>.</p>

<h2>
<a name="serial-flashing" class="anchor" href="#serial-flashing"><span class="octicon octicon-link"></span></a>Serial Flashing</h2>

<p>Ariadne bootloader supports flashing through serial like any other regular bootloader. This way of uploading
is built upon the default bootloaders so it should be pretty straight forward to use. Just plug in the
USB cable and select the serial port and the appropriate board from the <strong>Tools</strong> &gt; <strong>Board</strong> menu. After
that you must press the reset button and the indication LED on <strong>pin 13</strong> or <strong>pin 9</strong>, in case of Arduino
Ethernet, will start blinking rapidly. This means that the bootloader is running and the Arduino is ready
to be programmed. If there is a <strong>valid</strong> program already flashed on the Arduino, you have to reprogram
the device in the next <strong>5 seconds</strong>. If you don't, the bootloader will initiate the program that is
already in the Arduino. In case there is no program flashed or the program has been marked as <strong>invalid</strong>,
the bootloader will never time out and you can reprogram it at any time.</p>

<p>After a succesful flashing,</p>

<ul>
<li>
<em>Arduino Duemilanove</em> will automatically start the user's application.</li>
<li>
<em>Arduino Uno</em> will do a reset cycle and start the program after the bootloader times out.</li>
<li>
<em>Arduino Mega</em> will behave in a similar way as <em>Arduino Uno</em>
</li>
</ul><p>This happens because <em>Uno</em> has the autoreset feature that resets the board after a serial connection.</p>

<p>Due to the fact that "autoreset" for remote tftp programming is implemented using a watchdog timer timeout,
the bootloader will do a full cycle after every reset, physical or software. For those who miss the <em>Adaboot
No-Wait Mod</em>-like functionality, we have been testing some options on how to circumvent these limitations,
but they still need refinement.</p>

<h2>
<a name="default-network-settings" class="anchor" href="#default-network-settings"><span class="octicon octicon-link"></span></a>Default Network Settings</h2>

<p>The default built-in network settings of the bootloader are listed below.</p>

<p>`</p>

<ul>
<li>IP Address:  192.168.84.128</li>
<li>Subnet Mask: 255.255.255.0</li>
<li>Gateway:     192.168.84.1</li>
<li><p>MAC Address: 0xDE.0xAD.0xBE.0xEF.0xFE.0xED</p></li>
<li><p>TFTP Negotiation Port: 69</p></li>
<li>TFTP Data Port: 46969
`</li>
</ul><p><strong><em>NOTE:</em></strong> The Arduino Ethernet that were sent as Indiegogo Perks were flashed with different network
settings. Their bootloader still defaults to the previous settings <strong>but</strong> the current values are on
the accompaning leaflet.</p>

<h2>
<a name="configuring-network-settings" class="anchor" href="#configuring-network-settings"><span class="octicon octicon-link"></span></a>Configuring Network Settings</h2>

<p>These can be changed using our <strong>NetEEPROM</strong> library. The library is going to have it's own documentation
on how it can be used but for the purpose of changing and reading the network settings you can use the
included examples. To load them navigate to <strong>File</strong> &gt; <strong>Examples</strong> &gt; <strong>NetEEPROM</strong> and select one of
the examples. You can write the network settings using the <strong>WriteNetworkSettings</strong> sketch or print them
to the serial using the <strong>ReadNetworkSettings</strong>.</p>

<p>Note that the settings array in the <strong>WriteNetworkSettings</strong> sketch hasn't got the settings in the usual
order but rather in the order that <strong>W5100</strong> reads them, so make sure you have put the correct values.
If you set the network settings you also have to set the TFTP data transfer port. The default is good
enough but you may need to change it for the reasons that are listed below in the
<a href="https://github.com/codebendercc/Ariadne-Bootloader#configuring-your-router-for-remote-flashing">Configuring your Router for Remote Flashing</a> section. There is also documentation on how use
these sketches in the form of comments so be sure to read them.</p>

<h2>
<a name="tftp-flashing" class="anchor" href="#tftp-flashing"><span class="octicon octicon-link"></span></a>TFTP Flashing</h2>

<p>Now for the real reason we made this bootloader and why you should use it. First of all you can watch
<strong>Ariadne</strong> in action in this how-to video for remote flashing using TFTP <a href="http://youtu.be/KCHqhV6xPMg">here</a>. In the video you
may notice that the board is being reset by hand. In the next couple of weeks we are going to release
the library that will allow remote resetting through a simple web server with some security measures.
More on that as the library progresses.</p>

<h3>
<a name="converting-your-sketch-to-the-right-format" class="anchor" href="#converting-your-sketch-to-the-right-format"><span class="octicon octicon-link"></span></a>Converting your sketch to the right format</h3>

<p>Unlike serial flashing that uses <strong>HEX</strong> files to flash the Arduino, the TFTP server implemented in the
bootloader works with binary files. This means that you have to manually convert your programs to the
right format. To do that, first build your sketch inside <em>Arduino IDE</em> using the <strong>Verify</strong> button. After
that, without exiting the <em>Arduino IDE</em> you need to navigate to the temporary directory where your project
was built. On all platforms, you can find out the temporary build folder by checking
<code>Show verbose output during compilation</code> in <em>Arduino IDE</em>'s preferences dialog and the path for the
compiled <code>.hex</code> file will be printed in the last line of the compilation output.</p>

<h4>
<a name="windows" class="anchor" href="#windows"><span class="octicon octicon-link"></span></a>Windows</h4>

<p>On Windows, the temporary directory can be</p>

<pre><code>C:\Documents and Settings\Administrator\Local Settings\Temp\build5571819468326525374.tmp\Blink.cpp.hex
</code></pre>

<pre><code>"C:\Program Files\Arduino\hardware\tools\avr\bin\avr-objcopy.exe" -I ihex
"C:\Documents and Settings\Administrator\Local Settings\Temp\build5571819468326525374.tmp\Blink.cpp.hex"
-O binary Blink.cpp.bin
</code></pre>

<h4>
<a name="linux" class="anchor" href="#linux"><span class="octicon octicon-link"></span></a>Linux</h4>

<h4>
<a name="os-x" class="anchor" href="#os-x"><span class="octicon octicon-link"></span></a>OS X</h4>

<p>That is <code>C:\Users\owner\AppData\Local\Temp\</code> on <em>Windows</em>, <code>/tmp</code> on <em>Linux</em>. On <em>MacOS</em> you'll need
to go to Arduino's preferences, and check the "Show verbose output during compilation" checkbox. After
that, when you compile, you will see the path for the compiled .hex file in the last line of the compilation
output.. There you will find a folder named something like <code>build2429295348207572157.tmp</code>. That is where
the Arduino temporary build files reside. Enter the directory and make sure that there is a <code>.elf</code> or
a <code>.hex</code> file with the same name as your sketch. That is the file you need to convert. To achieve that
you have to run one of the following commands in a terminal.</p>

<ul>
<li><code>avr-objcopy -I ihex [sketch].hex -O binary [sketch].bin</code></li>
</ul><p>In Windows and MacOS you can find the <code>avr-objcopy</code> program in your Arduino IDE installation folder under
<code>hardware/tools/avr/bin/</code>. Or,if you have scons installed, you can use the modified <code>SConstruct</code> script
you can find in <code>SEM-Bootloader/utilities</code>. This being based on the <em>arscons</em> script, it can be used
in two ways. If you used the previous process to generate the <em>HEX</em> file you can just copy the <code>SConstruct</code>
file inside the temporary <em>Arduino IDE</em> build directory (as mentioned above) and run <code>scons</code> in a terminal
inside that directory.</p>

<p>The other way to use it is to copy the <code>SConstruct</code> script inside the sketch's directory and, as above,
run <code>scons</code> in a terminal inside that directory. This way you will build your project outside <em>Arduino
IDE</em> creating the <code>.bin</code> file in the process. Note that this way the sketch's folder will be polluted
with Arduino's build files, much like the temporary directory <em>Arduino IDE</em> uses.</p>

<p>For testing purposes you can find a <strong>blink</strong> sketch in binary form inside the
<code>SEM-Bootloader/utilities/tests/blink</code> folder. The <strong>fade</strong> sketch in the <code>tests/fade</code> folder
will also give you a view of what a failed upload looks like. This sketch fails because it is written
in plain <strong>C</strong> and not in <strong>Arduino</strong>. That way it lacks some "signatures" the bootloader uses to
validate <em>Arduino</em> sketches. The third sketch in <code>tests/led_display</code> is an easter egg for which you
need to find out how we had our led matrices connected on <em>Arduino Uno</em>. Or we might release the
schematics at some point. Who knows.</p>

<h3>
<a name="using-a-tftp-client-to-upload-the-sketch" class="anchor" href="#using-a-tftp-client-to-upload-the-sketch"><span class="octicon octicon-link"></span></a>Using a tftp client to upload the sketch</h3>

<p>Now that the binary is ready, you have to upload it. First you have to connect to your Arduino using
any tftp client you may have on your computer. All three major operating systems have their own clients
that you can use through the command line.</p>

<h4>
<a name="windows-1" class="anchor" href="#windows-1"><span class="octicon octicon-link"></span></a>Windows</h4>

<pre><code>Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.

C:\Documents and Settings\Administrator&gt;tftp

Transfers files to and from a remote computer running the TFTP service.

TFTP [-i] host [GET | PUT] source [destination]

  -i              Specifies binary image transfer mode (also called
                  octet). In binary image mode the file is moved
                  literally, byte by byte. Use this mode when
                  transferring binary files.
  host            Specifies the local or remote host.
  GET             Transfers the file destination on the remote host to
                  the file source on the local host.
  PUT             Transfers the file source on the local host to
                  the file destination on the remote host.
  source          Specifies the file to transfer.
  destination     Specifies where to transfer the file.


C:\Documents and Settings\Administrator&gt;tftp -i 192.168.84.128 PUT sketch.bin
tftp: can't read from local file 'sketch.bin'

C:\Documents and Settings\Administrator&gt;tftp -i 192.168.84.128 PUT sketch.bin
</code></pre>

<h4>
<a name="linux-1" class="anchor" href="#linux-1"><span class="octicon octicon-link"></span></a>Linux</h4>

<p>On some <strong>Linux</strong> distributions, like <strong>Fedora/RedHat</strong>, before you use <code>tftp</code>, you should load the <code>ip_conntrack_tftp</code>
module or the tftp client won't be able to acknowledge(<strong>ACK</strong>) the incoming packets. That is needed
because TFTP is insecure and it is not enabled by default. Other distributions like <strong>Arch</strong>, don't need
this step. To do that, open a terminal and run</p>

<pre><code>modprobe ip_conntrack_tftp
</code></pre>

<p>as <strong>root</strong> using <code>su</code> or <code>sudo</code>.</p>

<p>After that open a terminal as a regular user and type</p>

<pre><code>tftp [ip] [port]
</code></pre>

<p>For the default bootloader settings that would be:</p>

<pre><code>tftp 192.168.84.128 69
</code></pre>

<p>In this case it could just be <code>tftp 192.168.84.128</code> as <strong>69</strong> is the default tftp port and the client
would automatically connect to it. For any other port you have to explicitly set it.</p>

<p>Now you should have been greeted by the</p>

<pre><code>tftp&gt;
</code></pre>

<p>prompt.</p>

<p>First you have to enter this command:</p>

<pre><code>tftp&gt; mode octet
</code></pre>

<p>This way you tell the <strong>TFTP</strong> client to send binary data. This is absolutely needed as if your client
is in netascii mode, uploading will fail. After this, it is advised to use the two following commands
to make the process more informative so you can have a better view of what is happening, but they are
not needed.</p>

<pre><code>tftp&gt; trace
tftp&gt; verbose
</code></pre>

<p>Now to actually upload the binary file all you have to do is <strong>reset</strong> the board and in the next <strong>5
seconds</strong> run the following command.</p>

<pre><code>tftp&gt; put [sketch].bin
</code></pre>

<p>The <strong>5 second</strong> time frame is in case you already have a valid program uploaded on the Arduino. In case
you don't have a program loaded or it has been marked invalid, you don't have any time constraints.</p>

<p>Now you should see your tftp client sending packets and the indication LED on <strong>pin 13</strong> or <strong>pin 9</strong>
blinking in a random way, almost like having a hiccup. A correct output sample of the TFTP client uploading
the <em>blink</em> sketch is below:</p>

<pre><code>tftp&gt; mode octet
tftp&gt; trace
Trace mode on.
tftp&gt; verbose
Verbose mode on.
tftp&gt; put blink.bin
sent WRQ &lt;file: blink.bin, mode: octet &lt;&gt;&gt;
received ACK &lt;block: 0&gt;
sent DATA &lt;block: 1, size: 512&gt;
received ACK &lt;block: 1&gt;
sent DATA &lt;block: 2, size: 512&gt;
received ACK &lt;block: 2&gt;
sent DATA &lt;block: 3, size: 512&gt;
received ACK &lt;block: 3&gt;
sent DATA &lt;block: 4, size: 512&gt;
received ACK &lt;block: 4&gt;
sent DATA &lt;block: 5, size: 42&gt;
received ACK &lt;block: 5&gt;
tftp&gt;
</code></pre>

<p>After a successful upload the bootloader will start the uploaded application instantly.</p>

<p>In case that for some reason the upload fails, first of all stop your TFTP client from sending any more
packets. After that you should wait for the upload process on the bootloader to timeout. That takes about
<strong>5 seconds</strong> too. For this period you should witness the indication led doing some random blinking.
After the timeout and since there is no valid program in the memory, the TFTP server should restart itself
and wait for a new upload.</p>

<h2>
<a name="configuring-your-router-for-remote-flashing" class="anchor" href="#configuring-your-router-for-remote-flashing"><span class="octicon octicon-link"></span></a>Configuring your Router for Remote Flashing</h2>

<p>If you are having trouble flashing your Arduino at home from the road, you probably need to enable <a href="http://en.wikipedia.org/wiki/Port_forwarding">port
forwarding</a>. You need to forward ports <strong>69</strong> and <strong>46969</strong> to your Arduino in your router's configuration.
In case you have changed the incoming data port from <strong>46969</strong> to another port i.e. <strong>50232</strong>, you have
to forward <strong>50232</strong> port instead of <strong>46969</strong>. This is particularly useful when you have more than one
Arduinos, that you want to flash, behind your router. In addition to this you are going to have to translate
an external port of your choice on the router to the internal port and ip of the Arduino in the local
network.</p>

<p>An example is that you have 2 devices, one at <em>192.168.84.128</em> and one at <em>192.168.84.129</em>. They both listen
to port <strong>69</strong> for the initial connection. In this case you can translate external port <strong>6969</strong>(any
random port will do) on your router to <code>192.168.84.128:</code><strong>69</strong> and external port <strong>6970</strong> to
<code>192.168.84.129:</code><strong>69</strong> and specify these in the tftp client you are using.</p>

<p>Port Forward has <a href="http://portforward.com/english/routers/port_forwarding/">excellent guides</a> on how to enable port forwarding for a vast number of routers.</p>

<h2>
<a name="codebender" class="anchor" href="#codebender"><span class="octicon octicon-link"></span></a>Codebender</h2>

<p>One of the best and easiest ways to use this bootloader is along with <a href="http://codebender.cc">codebender.cc</a>. Just register,
enter your Arduino's IP (external IP for those in corporate or home networks behind NAT) and flash.</p>

<h2>
<a name="helper-libraries" class="anchor" href="#helper-libraries"><span class="octicon octicon-link"></span></a>Helper Libraries</h2>

<ul>
<li>
<a href="https://github.com/arjenhiemstra/SEM-Bootloader/tree/mega/libraries/libraries/NewEEPROM">NewEEPROM</a> (Patched EEPROM library to protect the memory space used by the bootloader)</li>
<li>
<a href="https://github.com/arjenhiemstra/SEM-Bootloader/tree/mega/libraries/libraries/NetEEPROM">NetEEPROM</a> (Library to manipulate the network settings of the bootloader)</li>
<li>
<a href="https://github.com/arjenhiemstra/SEM-Bootloader/tree/mega/libraries/libraries/EthernetReset">ResetServer</a> (Library used to create an HTTP server on the Arduino to enable remote resetting
of the microcontroller)</li>
</ul><h2>
<a name="supported-boards" class="anchor" href="#supported-boards"><span class="octicon octicon-link"></span></a>Supported Boards</h2>

<p>Supported MCUs:</p>

<ul>
<li><strong>ATmega328</strong></li>
<li><strong>ATmega2560</strong></li>
<li><strong>Atmega1284P</strong></li>
</ul><p>Supported ethernet controllers:</p>

<ul>
<li><strong>WizNet W5100</strong></li>
<li><strong>WizNet W5200</strong></li>
<li><strong>WizNet W5500</strong></li>
</ul><p>Tested Arduino Boards:</p>

<ul>
<li><a href="www.arduino.cc/en/Main/ArduinoBoardEthernet">Arduino Ethernet</a></li>
<li><a href="http://www.arduino.cc/en/Main/ArduinoBoardUno">Arduino Uno</a></li>
<li><a href="http://www.arduino.cc/en/Main/ArduinoBoardDuemilanove">Arduino Duemilanove w/ ATmega328</a></li>
<li><a href="http://arduino.cc/en/Main/arduinoBoardMega2560">Arduino Mega 2560</a></li>
<li><a href="http://www.getsem.info">SEM Energy Monitor</a></li>
</ul><h2>
<a name="other-tested-boards" class="anchor" href="#other-tested-boards"><span class="octicon octicon-link"></span></a>Other Tested Boards</h2>

<p>These boards have been also tested and found to be working with Ariadne Bootloader. I don't have any
of these so a big <strong><em>thank you</em></strong> goes to the people that took their time to test them.</p>

<ul>
<li><a href="http://imall.iteadstudio.com/im120410001.html">ITead Studio IBoard</a></li>
<li><a href="https://github.com/codebendercc/Ariadne-Bootloader">Sparkfun Ethernet Pro</a></li>
</ul><h2>
<a name="contributors" class="anchor" href="#contributors"><span class="octicon octicon-link"></span></a>Contributors</h2>

<p><a href="hemanzur@gmail.com">Hachi Manzur</a> (AVRISP mkII programmer, testing)</p>

<p>Over the time I will add more people who have helped in this list. If you feel that you should be in
this list, please contact me via email.</p>

<h2>
<a name="roadmap-outdated" class="anchor" href="#roadmap-outdated"><span class="octicon octicon-link"></span></a>Roadmap (outdated)</h2>

<p>Right now the main focus for the first packaged release is bug fixing and improve existing functionality.
That is why we encourage you to use the bootloader and report any bugs, misbehaviours or feature requests
here on github. There is also on going work to work on the Arduino Mega and support for Arduino Leonardo
is planned after that. Support for other ethernet or wifi controllers is being discussed but after the
bootloader has been stabilized.</p>

<h2>
<a name="acknoledgements" class="anchor" href="#acknoledgements"><span class="octicon octicon-link"></span></a>Acknoledgements</h2>

<p><strong>SEM-Bootloader</strong> bootloader is built upon some great open source projects.</p>

<ul>
<li>
<a href="https://github.com/codebendercc/Ariadne-Bootloader">Ariadne Bootloader</a> (The base of this project)</li>
<li>
<a href="https://code.google.com/p/optiboot/">Optiboot</a> (Serial flashing for <strong>ATmega328</strong>)</li>
<li>
<a href="https://github.com/msproul/Arduino-stk500v2-bootloader">Arduino-stk500v2-bootloader</a> (Serial flashing for <strong>ATmega2560</strong>)</li>
</ul><p>Credit should also go to <a href="https://github.com/mharizanov">mharizanov</a> for commenting some of the initial
<em>Arduino</em> code, making it easy for me to start and <a href="https://github.com/follower">follower</a> who's sketches
served as a starting point for the included <strong>NetEEPROM</strong> and <strong>EthernetReset</strong> libraries.</p>

<h2>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h2>

<p>This is free software and it is released under the <a href="https://www.gnu.org/licenses/gpl-2.0.html">GPLv2, GNU General Public License</a></p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">SEM-bootloader maintained by <a href="https://github.com/arjenhiemstra">arjenhiemstra</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
