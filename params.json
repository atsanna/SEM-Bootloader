{"name":"SEM-bootloader","tagline":"SEM TFTP bootloader for Arduino Ethernet (incl. support for Atmega 1284P and Wiznet W5200, W5500)","body":"# [SEM Bootloader for Arduino][1]\r\n[1]: http://github.com/arjenhiemstra/SEM-Bootloader/\r\n\r\n### TFTP Bootloader for ATmega328P/Atmega2560/Atmega1284P ###\r\n\r\n#### /w support for Wiznet5100, W5200 and W5500 ####\r\n\r\nThis is a beta stage bootloader for Arduino Ethernet board and the regular Arduino with Ethernet Shield.\r\nIt is based on previous unfinished work by the Arduino developers. The bootloader implements a TFTP\r\nserver on the Arduino board and flashing works using any regular TFTP client.\r\n\r\n\r\n## The Files and Folders in this Repository\r\nThe structure of this repository is made to follow the standarts of the Arduino IDE. This way you can\r\nsimply copy the folders in your sketchbook and be ready\r\n\r\n* hardware: This is where the bootloader resides.\r\n* java-client: Demo client for the bootloader. Inherited by the initial project. Untested and probably non-functional\r\n* libraries: Helper libraries to support functions of the bootloader\r\n* utilities: Various stuff used for development and debugging\r\n\r\n\r\n## Downloading and Installing Files\r\nFirst of all, you need to clone or download the repository. To clone the repository you need to have\r\ngit installed, then you can run `git clone https://github.com/arjenhiemstra/SEM-Bootloader.git` in a\r\ndirectory. This way you can later update your local repository by running `git pull` inside the\r\n__SEM-Bootloader__ directory.\r\n\r\nIn case you want to avoid this hassle, you can use the __ZIP__ button at the top of the page to download\r\nthe latest snapshot of the repository in a zip archive and extract it.\r\n\r\nAfter that you have to copy the __hardware__ and __libraries__ folders inside your sketchbook folder.\r\nTake extra care during coping not to overwrite any other files. Restart the Arduino IDE to load the new\r\nboards and libraries.\r\n\r\n\r\n## Installing the Bootloader\r\nTo burn the bootloader, you will need an ISP(in-system programmer) like [AVR-ISP][2], [USBtinyISP][3]\r\nor you can build a [ParallelProgrammer][4] or an [ArduinoISP][5]. The first three programmers should\r\nbe connected to the ICSP pins (the 2 by 3 pin header) and make sure you plug it in the right way. The\r\nboard must be powered by an external power supply or the USB port. In the case of _ArduinoISP_ you\r\nshould consult the above link for further instructions on how to build and use.\r\n[2]: http://www.atmel.com/dyn/products/tools_card.asp?tool_id=2726\r\n[3]: http://www.ladyada.net/make/usbtinyisp/\r\n[4]: http://arduino.cc/en/Hacking/ParallelProgrammer\r\n[5]: http://arduino.cc/en/Tutorial/ArduinoISP\r\n\r\nAfter you have connected the Arduino board and the programmer to your computer launch the Arduino IDE.\r\nNavigate to the __Tools__ > __Board__ menu and select `SEMboot Atmega <chip> (<Wiznet Chip>)` which\r\nreflects your Arduino/Atmega board and wiznet chip combination.\r\nThen go to __Tools__ > __Programmer__ and select the programmer you are using.\r\nIn case you are using _ArduinoISP_, make sure that the selected port in the __Tools__ > __Serial Port__\r\nmenu refers to the _ArduinoISP_ and not the board that you want to burn the bootloader on. Now, just\r\nlaunch the __Tools__ > __Burn Bootloader__ command and wait for about 15 seconds for the operation\r\nto complete.\r\n\r\nIn the case of _Arduino Mega_ the previous ISPs do not reliably work because of design differences. To\r\ninstall the bootloader in these boards you will need one of the more expensive models,\r\nlike [Atmel's AVRISP mkII][6], [Olimex's AVR-ISP-MK2][7] or another similar programmer. If you don't\r\nhave any compatible programmer but more than one Arduinos available, you can use Nick Gammon's\r\nexcellent [guide][8] on how to use one to program the other. This method has been reported to work\r\nfor flashing __Ariadne__ on _Arduino Mega_.\r\n[6]: http://www.atmel.com/tools/AVRISPMKII.aspx\r\n[7]: https://www.olimex.com/Products/AVR/Programmers/AVR-ISP-MK2/\r\n[8]: http://www.gammon.com.au/forum/?id=11635\r\n\r\n\r\n## Serial Flashing\r\nAriadne bootloader supports flashing through serial like any other regular bootloader. This way of uploading\r\nis built upon the default bootloaders so it should be pretty straight forward to use. Just plug in the\r\nUSB cable and select the serial port and the appropriate board from the __Tools__ > __Board__ menu. After\r\nthat you must press the reset button and the indication LED on __pin 13__ or __pin 9__, in case of Arduino\r\nEthernet, will start blinking rapidly. This means that the bootloader is running and the Arduino is ready\r\nto be programmed. If there is a __valid__ program already flashed on the Arduino, you have to reprogram\r\nthe device in the next __5 seconds__. If you don't, the bootloader will initiate the program that is\r\nalready in the Arduino. In case there is no program flashed or the program has been marked as __invalid__,\r\nthe bootloader will never time out and you can reprogram it at any time.\r\n\r\nAfter a succesful flashing,\r\n\r\n* _Arduino Duemilanove_ will automatically start the user's application.\r\n* _Arduino Uno_ will do a reset cycle and start the program after the bootloader times out.\r\n* _Arduino Mega_ will behave in a similar way as _Arduino Uno_\r\n\r\nThis happens because _Uno_ has the autoreset feature that resets the board after a serial connection.\r\n\r\nDue to the fact that \"autoreset\" for remote tftp programming is implemented using a watchdog timer timeout,\r\nthe bootloader will do a full cycle after every reset, physical or software. For those who miss the _Adaboot\r\nNo-Wait Mod_-like functionality, we have been testing some options on how to circumvent these limitations,\r\nbut they still need refinement.\r\n\r\n\r\n## Default Network Settings\r\nThe default built-in network settings of the bootloader are listed below.\r\n\r\n`\r\n* IP Address:  192.168.84.128\r\n* Subnet Mask: 255.255.255.0\r\n* Gateway:     192.168.84.1\r\n* MAC Address: 0xDE.0xAD.0xBE.0xEF.0xFE.0xED\r\n\r\n* TFTP Negotiation Port: 69\r\n* TFTP Data Port: 46969\r\n`\r\n\r\n___NOTE:___ The Arduino Ethernet that were sent as Indiegogo Perks were flashed with different network\r\nsettings. Their bootloader still defaults to the previous settings __but__ the current values are on\r\nthe accompaning leaflet.\r\n\r\n\r\n## Configuring Network Settings\r\nThese can be changed using our __NetEEPROM__ library. The library is going to have it's own documentation\r\non how it can be used but for the purpose of changing and reading the network settings you can use the\r\nincluded examples. To load them navigate to __File__ > __Examples__ > __NetEEPROM__ and select one of\r\nthe examples. You can write the network settings using the __WriteNetworkSettings__ sketch or print them\r\nto the serial using the __ReadNetworkSettings__.\r\n\r\nNote that the settings array in the __WriteNetworkSettings__ sketch hasn't got the settings in the usual\r\norder but rather in the order that __W5100__ reads them, so make sure you have put the correct values.\r\nIf you set the network settings you also have to set the TFTP data transfer port. The default is good\r\nenough but you may need to change it for the reasons that are listed below in the\r\n[Configuring your Router for Remote Flashing][9] section. There is also documentation on how use\r\nthese sketches in the form of comments so be sure to read them.\r\n[9]: https://github.com/codebendercc/Ariadne-Bootloader#configuring-your-router-for-remote-flashing\r\n\r\n## TFTP Flashing\r\nNow for the real reason we made this bootloader and why you should use it. First of all you can watch\r\n__Ariadne__ in action in this how-to video for remote flashing using TFTP [here][10]. In the video you\r\nmay notice that the board is being reset by hand. In the next couple of weeks we are going to release\r\nthe library that will allow remote resetting through a simple web server with some security measures.\r\nMore on that as the library progresses.\r\n[10]: http://youtu.be/KCHqhV6xPMg\r\n\r\n### Converting your sketch to the right format\r\nUnlike serial flashing that uses __HEX__ files to flash the Arduino, the TFTP server implemented in the\r\nbootloader works with binary files. This means that you have to manually convert your programs to the\r\nright format. To do that, first build your sketch inside _Arduino IDE_ using the __Verify__ button. After\r\nthat, without exiting the _Arduino IDE_ you need to navigate to the temporary directory where your project\r\nwas built. On all platforms, you can find out the temporary build folder by checking\r\n`Show verbose output during compilation` in _Arduino IDE_'s preferences dialog and the path for the\r\ncompiled `.hex` file will be printed in the last line of the compilation output.\r\n\r\n#### Windows\r\nOn Windows, the temporary directory can be\r\n\r\n```\r\nC:\\Documents and Settings\\Administrator\\Local Settings\\Temp\\build5571819468326525374.tmp\\Blink.cpp.hex\r\n```\r\n\r\n```\r\n\"C:\\Program Files\\Arduino\\hardware\\tools\\avr\\bin\\avr-objcopy.exe\" -I ihex\r\n\"C:\\Documents and Settings\\Administrator\\Local Settings\\Temp\\build5571819468326525374.tmp\\Blink.cpp.hex\"\r\n-O binary Blink.cpp.bin\r\n```\r\n#### Linux\r\n\r\n#### OS X\r\nThat is `C:\\Users\\owner\\AppData\\Local\\Temp\\` on *Windows*, `/tmp` on *Linux*. On *MacOS* you'll need\r\nto go to Arduino's preferences, and check the \"Show verbose output during compilation\" checkbox. After\r\nthat, when you compile, you will see the path for the compiled .hex file in the last line of the compilation\r\noutput.. There you will find a folder named something like `build2429295348207572157.tmp`. That is where\r\nthe Arduino temporary build files reside. Enter the directory and make sure that there is a `.elf` or\r\na `.hex` file with the same name as your sketch. That is the file you need to convert. To achieve that\r\nyou have to run one of the following commands in a terminal.\r\n\r\n* `avr-objcopy -I ihex [sketch].hex -O binary [sketch].bin`\r\n\r\nIn Windows and MacOS you can find the `avr-objcopy` program in your Arduino IDE installation folder under\r\n`hardware/tools/avr/bin/`. Or,if you have scons installed, you can use the modified `SConstruct` script\r\nyou can find in `SEM-Bootloader/utilities`. This being based on the *arscons* script, it can be used\r\nin two ways. If you used the previous process to generate the _HEX_ file you can just copy the `SConstruct`\r\nfile inside the temporary *Arduino IDE* build directory (as mentioned above) and run `scons` in a terminal\r\ninside that directory.\r\n\r\nThe other way to use it is to copy the `SConstruct` script inside the sketch's directory and, as above,\r\nrun `scons` in a terminal inside that directory. This way you will build your project outside *Arduino\r\nIDE* creating the `.bin` file in the process. Note that this way the sketch's folder will be polluted\r\nwith Arduino's build files, much like the temporary directory *Arduino IDE* uses.\r\n\r\nFor testing purposes you can find a __blink__ sketch in binary form inside the\r\n`SEM-Bootloader/utilities/tests/blink` folder. The __fade__ sketch in the `tests/fade` folder\r\nwill also give you a view of what a failed upload looks like. This sketch fails because it is written\r\nin plain __C__ and not in __Arduino__. That way it lacks some \"signatures\" the bootloader uses to\r\nvalidate _Arduino_ sketches. The third sketch in `tests/led_display` is an easter egg for which you\r\nneed to find out how we had our led matrices connected on _Arduino Uno_. Or we might release the\r\nschematics at some point. Who knows.\r\n\r\n### Using a tftp client to upload the sketch\r\nNow that the binary is ready, you have to upload it. First you have to connect to your Arduino using\r\nany tftp client you may have on your computer. All three major operating systems have their own clients\r\nthat you can use through the command line.\r\n\r\n#### Windows\r\n```\r\nMicrosoft Windows XP [Version 5.1.2600]\r\n(C) Copyright 1985-2001 Microsoft Corp.\r\n\r\nC:\\Documents and Settings\\Administrator>tftp\r\n\r\nTransfers files to and from a remote computer running the TFTP service.\r\n\r\nTFTP [-i] host [GET | PUT] source [destination]\r\n\r\n  -i              Specifies binary image transfer mode (also called\r\n                  octet). In binary image mode the file is moved\r\n                  literally, byte by byte. Use this mode when\r\n                  transferring binary files.\r\n  host            Specifies the local or remote host.\r\n  GET             Transfers the file destination on the remote host to\r\n                  the file source on the local host.\r\n  PUT             Transfers the file source on the local host to\r\n                  the file destination on the remote host.\r\n  source          Specifies the file to transfer.\r\n  destination     Specifies where to transfer the file.\r\n\r\n\r\nC:\\Documents and Settings\\Administrator>tftp -i 192.168.84.128 PUT sketch.bin\r\ntftp: can't read from local file 'sketch.bin'\r\n\r\nC:\\Documents and Settings\\Administrator>tftp -i 192.168.84.128 PUT sketch.bin\r\n```\r\n\r\n#### Linux\r\nOn some __Linux__ distributions, like __Fedora/RedHat__, before you use `tftp`, you should load the `ip_conntrack_tftp`\r\nmodule or the tftp client won't be able to acknowledge(__ACK__) the incoming packets. That is needed\r\nbecause TFTP is insecure and it is not enabled by default. Other distributions like __Arch__, don't need\r\nthis step. To do that, open a terminal and run\r\n```\r\nmodprobe ip_conntrack_tftp\r\n```\r\nas __root__ using `su` or `sudo`.\r\n\r\nAfter that open a terminal as a regular user and type\r\n```\r\ntftp [ip] [port]\r\n```\r\n\r\nFor the default bootloader settings that would be:\r\n```\r\ntftp 192.168.84.128 69\r\n```\r\nIn this case it could just be `tftp 192.168.84.128` as __69__ is the default tftp port and the client\r\nwould automatically connect to it. For any other port you have to explicitly set it.\r\n\r\nNow you should have been greeted by the\r\n```\r\ntftp>\r\n```\r\nprompt.\r\n\r\nFirst you have to enter this command:\r\n```\r\ntftp> mode octet\r\n```\r\nThis way you tell the __TFTP__ client to send binary data. This is absolutely needed as if your client\r\nis in netascii mode, uploading will fail. After this, it is advised to use the two following commands\r\nto make the process more informative so you can have a better view of what is happening, but they are\r\nnot needed.\r\n```\r\ntftp> trace\r\ntftp> verbose\r\n```\r\nNow to actually upload the binary file all you have to do is __reset__ the board and in the next __5\r\nseconds__ run the following command.\r\n```\r\ntftp> put [sketch].bin\r\n```\r\nThe __5 second__ time frame is in case you already have a valid program uploaded on the Arduino. In case\r\nyou don't have a program loaded or it has been marked invalid, you don't have any time constraints.\r\n\r\nNow you should see your tftp client sending packets and the indication LED on __pin 13__ or __pin 9__\r\nblinking in a random way, almost like having a hiccup. A correct output sample of the TFTP client uploading\r\nthe *blink* sketch is below:\r\n```\r\ntftp> mode octet\r\ntftp> trace\r\nTrace mode on.\r\ntftp> verbose\r\nVerbose mode on.\r\ntftp> put blink.bin\r\nsent WRQ <file: blink.bin, mode: octet <>>\r\nreceived ACK <block: 0>\r\nsent DATA <block: 1, size: 512>\r\nreceived ACK <block: 1>\r\nsent DATA <block: 2, size: 512>\r\nreceived ACK <block: 2>\r\nsent DATA <block: 3, size: 512>\r\nreceived ACK <block: 3>\r\nsent DATA <block: 4, size: 512>\r\nreceived ACK <block: 4>\r\nsent DATA <block: 5, size: 42>\r\nreceived ACK <block: 5>\r\ntftp>\r\n```\r\nAfter a successful upload the bootloader will start the uploaded application instantly.\r\n\r\nIn case that for some reason the upload fails, first of all stop your TFTP client from sending any more\r\npackets. After that you should wait for the upload process on the bootloader to timeout. That takes about\r\n__5 seconds__ too. For this period you should witness the indication led doing some random blinking.\r\nAfter the timeout and since there is no valid program in the memory, the TFTP server should restart itself\r\nand wait for a new upload.\r\n\r\n\r\n## Configuring your Router for Remote Flashing\r\nIf you are having trouble flashing your Arduino at home from the road, you probably need to enable [port\r\nforwarding][11]. You need to forward ports __69__ and __46969__ to your Arduino in your router's configuration.\r\nIn case you have changed the incoming data port from __46969__ to another port i.e. __50232__, you have\r\nto forward __50232__ port instead of __46969__. This is particularly useful when you have more than one\r\nArduinos, that you want to flash, behind your router. In addition to this you are going to have to translate\r\nan external port of your choice on the router to the internal port and ip of the Arduino in the local\r\nnetwork.\r\n[11]: http://en.wikipedia.org/wiki/Port_forwarding\r\n\r\nAn example is that you have 2 devices, one at *192.168.84.128* and one at *192.168.84.129*. They both listen\r\nto port __69__ for the initial connection. In this case you can translate external port __6969__(any\r\nrandom port will do) on your router to `192.168.84.128:`__69__ and external port __6970__ to\r\n`192.168.84.129:`__69__ and specify these in the tftp client you are using.\r\n\r\nPort Forward has [excellent guides][12] on how to enable port forwarding for a vast number of routers.\r\n[12]: http://portforward.com/english/routers/port_forwarding/\r\n\r\n## Codebender\r\nOne of the best and easiest ways to use this bootloader is along with [codebender.cc][13]. Just register,\r\nenter your Arduino's IP (external IP for those in corporate or home networks behind NAT) and flash.\r\n[13]: http://codebender.cc\r\n\r\n## Helper Libraries\r\n* [NewEEPROM][14] (Patched EEPROM library to protect the memory space used by the bootloader)\r\n* [NetEEPROM][15] (Library to manipulate the network settings of the bootloader)\r\n* [ResetServer][16] (Library used to create an HTTP server on the Arduino to enable remote resetting\r\nof the microcontroller)\r\n[14]: https://github.com/arjenhiemstra/SEM-Bootloader/tree/mega/libraries/libraries/NewEEPROM\r\n[15]: https://github.com/arjenhiemstra/SEM-Bootloader/tree/mega/libraries/libraries/NetEEPROM\r\n[16]: https://github.com/arjenhiemstra/SEM-Bootloader/tree/mega/libraries/libraries/EthernetReset\r\n\r\n## Supported Boards\r\nSupported MCUs:\r\n\r\n* __ATmega328__\r\n* __ATmega2560__\r\n* __Atmega1284P__\r\n\r\nSupported ethernet controllers:\r\n\r\n* __WizNet W5100__\r\n* __WizNet W5200__\r\n* __WizNet W5500__\r\n\r\nTested Arduino Boards:\r\n\r\n* [Arduino Ethernet][17]\r\n* [Arduino Uno][18]\r\n* [Arduino Duemilanove w/ ATmega328][19]\r\n* [Arduino Mega 2560][20]\r\n* [SEM Energy Monitor][21]\r\n[17]: www.arduino.cc/en/Main/ArduinoBoardEthernet\r\n[18]: http://www.arduino.cc/en/Main/ArduinoBoardUno\r\n[19]: http://www.arduino.cc/en/Main/ArduinoBoardDuemilanove\r\n[20]: http://arduino.cc/en/Main/arduinoBoardMega2560\r\n[21]: http://www.getsem.info\r\n## Other Tested Boards\r\nThese boards have been also tested and found to be working with Ariadne Bootloader. I don't have any\r\nof these so a big ___thank you___ goes to the people that took their time to test them.\r\n\r\n* [ITead Studio IBoard][22]\r\n* [Sparkfun Ethernet Pro][23]\r\n[22]: http://imall.iteadstudio.com/im120410001.html\r\n[23]: https://www.sparkfun.com/products/10536\r\n\r\n## Contributors\r\n[Hachi Manzur](hemanzur@gmail.com) (AVRISP mkII programmer, testing)\r\n\r\nOver the time I will add more people who have helped in this list. If you feel that you should be in\r\nthis list, please contact me via email.\r\n\r\n\r\n## Roadmap (outdated)\r\nRight now the main focus for the first packaged release is bug fixing and improve existing functionality.\r\nThat is why we encourage you to use the bootloader and report any bugs, misbehaviours or feature requests\r\nhere on github. There is also on going work to work on the Arduino Mega and support for Arduino Leonardo\r\nis planned after that. Support for other ethernet or wifi controllers is being discussed but after the\r\nbootloader has been stabilized.\r\n\r\n\r\n## Acknoledgements\r\n__SEM-Bootloader__ bootloader is built upon some great open source projects.\r\n\r\n* [Ariadne Bootloader][23] (The base of this project)\r\n* [Optiboot][24] (Serial flashing for __ATmega328__)\r\n* [Arduino-stk500v2-bootloader][25] (Serial flashing for __ATmega2560__)\r\n[23]: https://github.com/codebendercc/Ariadne-Bootloader\r\n[24]: https://code.google.com/p/optiboot/\r\n[25]: https://github.com/msproul/Arduino-stk500v2-bootloader\r\n\r\nCredit should also go to [mharizanov](https://github.com/mharizanov) for commenting some of the initial\r\n*Arduino* code, making it easy for me to start and [follower](https://github.com/follower) who's sketches\r\nserved as a starting point for the included __NetEEPROM__ and __EthernetReset__ libraries.\r\n\r\n\r\n## License\r\nThis is free software and it is released under the [GPLv2, GNU General Public License][99]\r\n[99]: https://www.gnu.org/licenses/gpl-2.0.html\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}